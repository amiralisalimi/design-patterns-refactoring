# DesignPatternsRefactoring
SE Lab - Assignment 6 - SUT | 14033 

# بخش اول
<div dir="rtl">

# سیستم مدیریت پویای مصرف انرژی هوشمند (README)

این پروژه یک شبیه‌سازی ساده از مدیریت انرژی در یک ساختمان اداری است. سیستم باید بتواند با توجه به شرایط، حالت کار تجهیزات را تغییر دهد و هم‌زمان هزینه‌ی انرژی را با سیاست‌های مختلف محاسبه کند. پیاده‌سازی بر پایه‌ی دو الگوی رفتاری State و Strategy انجام شده و روند توسعه با رویکرد TDD پیش رفته است.

---

## الگوهای طراحی به‌کاررفته و چرایی آن‌ها

## پرسش ۲

هر دو الگوی State و Strategy در دسته‌ی الگوهای رفتاری یا Behavioral قرار می‌گیرند.

## پرسش ۳

برای مدیریت حالت‌های سیستم از الگوی State استفاده شده است. دلیل اصلی این انتخاب آن است که وضعیت سیستم همیشه یکی از سه حالت مشخص است: فعال، اقتصادی یا خاموش. هر حالت رفتار مخصوص به خودش دارد و اگر بخواهیم همه این رفتارها را با شرط‌های پشت سر هم در یک کلاس قرار دهیم، کد پیچیده می‌شود. State کمک می‌کند هر حالت به شکل یک کلاس مستقل تعریف شود و تغییر حالت فقط با جایگزین کردن شیء جدید انجام شود. به این ترتیب هم خوانایی کد بالا می‌رود و هم افزودن حالت‌های تازه بدون دست‌کاری منطق فعلی ممکن خواهد بود.

برای محاسبه هزینه انرژی از الگوی Strategy استفاده شده است. Strategy برای زمانی استفاده می‌شود که یک <B>الگوریتم یا سیاست</B> قابل تعویض است و مستقل از وضعیت سیستم است. چون سیاست‌های محاسبه هزینه ممکن است در زمان اجرا تغییر کنند، بهتر است منطق هر تعرفه در یک استراتژی جداگانه نگهداری شود. به این شکل کلاس محاسبه هزینه صرفاً به یک اینترفیس عمومی متکی است و نیازی ندارد بداند تعرفه فعلی معمولی است یا اوج مصرف یا سبز. تغییر تعرفه هم فقط با تغییر استراتژی انجام می‌شود. این باعث می‌شود کد باز و قابل توسعه بماند و بتوان سیاست‌های جدیدی را به‌سادگی اضافه کرد.

به طور خلاصه، State برای زمانی استفاده شد که رفتار سیستم به وضعیت جاری آن وابسته بود و Strategy برای زمانی به‌کار رفت که روش محاسبه هزینه قابل تعویض بود.

## تحقق الگوها در پیاده‌سازی

پیاده‌سازی State به این شکل است که یک اینترفیس EnergyState تعریف شده است و هر حالت سیستم (ActiveState، EcoState، ShutdownState) یک کلاس مجزا پیاده‌سازی می‌کند. BuildingContext حالت جاری را نگه می‌دارد و با فراخوانی متد setState می‌توان وضعیت را تغییر داد. این طراحی تضمین می‌کند که هر تغییر وضعیت، رفتار سیستم را به صورت خودکار به‌روز می‌کند و کد اصلی وابستگی مستقیم به حالت ندارد.

پیاده‌سازی Strategy شامل تعریف یک اینترفیس CostStrategy است که متد calculateCost را ارائه می‌دهد. هر تعرفه انرژی یک کلاس پیاده‌ساز است (StandardCostStrategy، PeakCostStrategy، GreenCostStrategy) و CostCalculator استراتژی جاری را نگه می‌دارد. تغییر تعرفه با فراخوانی setStrategy انجام می‌شود و هیچ تغییری در کد بخش‌های دیگر نیاز نیست. این طراحی تحقق کامل استقلال و تعویض‌پذیری الگوریتم محاسبه هزینه را نشان می‌دهد.

---

## معماری و پیاده‌سازی

ساختار کد به دو بسته اصلی تقسیم شده است: state و strategy. کلاس MainApp منوی متنی و جریان اجرای برنامه را مدیریت می‌کند و نقش‌های Manager و User را از هم جدا می‌کند.

### بخش State (وضعیت سیستم انرژی)

EnergyState یک اینترفیس با دو متد است: getEnergyConsumption و getStatus. سه کلاس پیاده‌ساز عبارتند از ActiveState با مصرف صد واحد و پیام «System is fully active»، EcoState با مصرف چهل واحد و پیام «System is in eco mode»، و ShutdownState با مصرف صفر واحد و پیام «System is shut down». کلاس BuildingContext فقط به اینترفیس State تکیه دارد، حالت جاری را نگه می‌دارد و از طریق setState تعویض می‌کند. برای نمایش وضعیت showStatus و برای دسترسی به مصرف جاری getCurrentConsumption ارائه می‌دهد.

### بخش Strategy (سیاست محاسبه هزینه)

CostStrategy اینترفیس محاسبه هزینه است که متد calculateCost را تعریف می‌کند. پیاده‌سازی‌ها شامل StandardCostStrategy با نرخ پانصد، PeakCostStrategy با نرخ هزار و GreenCostStrategy با نرخ سیصد هستند. کلاس CostCalculator نقش Context را دارد و استراتژی جاری را نگه می‌دارد. تغییر تعرفه فقط با setStrategy انجام می‌شود.

### رابط کاربری و نقش‌ها

برنامه اصلی با منو اجرا می‌شود. ابتدا نقش انتخاب می‌شود. اگر Manager انتخاب شود امکان تغییر حالت سیستم یا تغییر سیاست هزینه وجود دارد. اگر User انتخاب شود می‌توان وضعیت فعلی را دید، هزینه کل را بر اساس مصرف حالت جاری محاسبه کرد یا تعداد واحد دلخواهی را برای شبیه‌سازی وارد کرد. برنامه از ابتدا با حالت Active و سیاست Standard بالا می‌آید.

---

## آزمون‌های TDD

توسعه با نوشتن تست‌ها آغاز شد. ابتدا تست‌های شکست‌خورده برای هر دو بخش نوشته شد و سپس حداقل کد لازم برای سبز شدن آن‌ها پیاده شد. در بخش Strategy، آزمون‌ها صحت اعداد هر تعرفه و قابلیت تعویض استراتژی در زمان اجرا را بررسی می‌کنند. در بخش State، آزمون‌ها اطمینان می‌دهند که هر حالت مقدار مصرف و پیام متناظر خود را دارد. این روند باعث شد با رشد کد، اعتماد به رفتار سیستم حفظ شود و هر تغییر به سرعت با آزمون پوشش داده شود.
</div>



# بخش دوم

# ریفکتورها و بازآرایی‌های پروژه MiniJava

## Facade – CompilerFacade و Compiler
یک Facade برای Compiler ساخته شد تا دسترسی به Parser و Scanner ساده شود. کاربران دیگر نیازی به ایجاد یا مدیریت مستقیم این کلاس‌ها ندارند و فقط با CompilerFacade کار می‌کنند.

## Strategy – ActionStrategy
برای جایگزینی switch-case در parser، هر نوع Action (Shift, Reduce, Accept) یک کلاس جداگانه با متد execute دارد. این باعث شد اضافه کردن action جدید بدون تغییر در parser ممکن شود و کد خواناتر و قابل تست‌تر شود.

## Separate Query from Modifier
توابعی که داده را query می‌کنند نباید هیچ side-effect یا تغییر وضعیت ایجاد کنند. عملیات تغییر وضعیت و ErrorHandler در توابع جداگانه انجام شد تا عملیات خواندن داده بدون اثر جانبی باشد.

## Self Encapsulated Field
فیلدهای کلاس‌ها private شدند و تمام دسترسی‌ها از طریق getter و setter انجام می‌شود. این کار باعث کنترل بهتر روی فیلدها و امکان اضافه کردن validation می‌شود.

## Null Object – Klass.getField
به جای بازگرداندن null هنگام پیدا نشدن فیلد، یک NullSymbol امن برگردانده می‌شود. این روش جلوی NullPointerException را می‌گیرد و کد کلاینت بدون نیاز به بررسی null، پیش‌بینی‌پذیر است.

## Extract Method – ParseTable
کد parsing جدول parser در constructor به متدهای جداگانه مثل parseRow و parsecol منتقل شد. constructor کوتاه‌تر و خواناتر شد. Magic String ها نیز به صورت ثابت تعریف شدند تا کد خواناتر شود.


# پاسخ سوالات

## سوال ۱
### 1- Creational
<p>تمرکر این دسته روی نحوه ایجاد و نمونه سازی از اشیا است به شکلی که سیستم کمتر به جزئیات ایجاد وابسته باشد. این الگو ها انعطاف پذیری  در ایجاد اشیا و کپسوله سازی روند ساخت را فراهم می‌کنند.</p>

#### نمونه ها
- Singleton
- Factory Method

### 2- Structural
<p>این دسته روی ترکیب کلاس ها و اشیا تمرکز دارد تا ساختار های بزرگ تر و انعطاف پذیر تر ساخته شوند. هدف اصلی آن ساده سازی روابط و ترکیب ها برای افزایش قابلیت استفاده مجدد است.</p>

#### نمونه ها
- Adapter
- Composite

### 3- Behavioral
<p>این دسته به نحوه تعامل و مسئولیت بین اشیا می پردازد.  هدف آن تعریف الگوهایی برای ارتباط، همکاری و تخصیص وظایف میان اشیا است.</p>

#### نمونه ها
- Observer
- Strategy

## پرسش ۲

<div dir="rtl">

هر دو الگوی State و Strategy در دسته‌ی الگوهای رفتاری یا Behavioral قرار می‌گیرند.

</div>

## پرسش ۳

<div dir="rtl">

برای مدیریت حالت‌های سیستم از الگوی State استفاده شده است. دلیل اصلی این انتخاب آن است که وضعیت سیستم همیشه یکی از سه حالت مشخص است: فعال، اقتصادی یا خاموش. هر حالت رفتار مخصوص به خودش دارد و اگر بخواهیم همه این رفتارها را با شرط‌های پشت سر هم در یک کلاس قرار دهیم، کد پیچیده می‌شود. State کمک می‌کند هر حالت به شکل یک کلاس مستقل تعریف شود و تغییر حالت فقط با جایگزین کردن شیء جدید انجام شود. به این ترتیب هم خوانایی کد بالا می‌رود و هم افزودن حالت‌های تازه بدون دست‌کاری منطق فعلی ممکن خواهد بود.

برای محاسبه هزینه انرژی از الگوی Strategy استفاده شده است. Strategy برای زمانی استفاده می‌شود که یک <B>الگوریتم یا سیاست</B> قابل تعویض است و مستقل از وضعیت سیستم است. چون سیاست‌های محاسبه هزینه ممکن است در زمان اجرا تغییر کنند، بهتر است منطق هر تعرفه در یک استراتژی جداگانه نگهداری شود. به این شکل کلاس محاسبه هزینه صرفاً به یک اینترفیس عمومی متکی است و نیازی ندارد بداند تعرفه فعلی معمولی است یا اوج مصرف یا سبز. تغییر تعرفه هم فقط با تغییر استراتژی انجام می‌شود. این باعث می‌شود کد باز و قابل توسعه بماند و بتوان سیاست‌های جدیدی را به‌سادگی اضافه کرد.

به طور خلاصه، State برای زمانی استفاده شد که رفتار سیستم به وضعیت جاری آن وابسته بود و Strategy برای زمانی به‌کار رفت که روش محاسبه هزینه قابل تعویض بود.

</div>

## سوال ۴

<div dir='rtl'>

### اصل S (Single Responsibility Principle)
الگوی Factory Method این اصل را تحقق می‌بخشد.  
در این الگو، مسئولیت ایجاد اشیاء به کلاس factory سپرده می‌شود و کلاس‌های دیگر فقط از اشیاء استفاده می‌کنند بدون دخالت در فرآیند ساخت.  
این جداسازی مسئولیت‌ها باعث می‌شود هر کلاس تنها یک وظیفه داشته باشد و کد تمیزتر شود.

### اصل O (Open-Closed Principle)
الگوی Factory Method این اصل را تحقق می‌بخشد.  
کلاس factory برای گسترش باز است، زیرا می‌توان زیرکلاس‌های جدیدی اضافه کرد تا انواع جدیدی از اشیاء ایجاد شود بدون تغییر کد موجود.  
در عین حال، برای تغییرات بسته است، زیرا کد کلاینت وابسته به abstraction است و نیاز به اصلاح ندارد.

### اصل L (Liskov Substitution Principle)
الگوی Factory Method این اصل را تحقق می‌بخشد.  
زیرکلاس‌های factory می‌توانند جایگزین superclass شوند، زیرا متد factory را override می‌کنند بدون اینکه رفتار کلی سیستم را مختل کنند.  
این اصل تضمین می‌کند که اشیاء ساخته‌شده توسط زیرکلاس‌ها با انتظارات superclass سازگار باشند.

### اصل I (Interface Segregation Principle)
الگوی Factory Method این اصل را تحقق می‌بخشد.  
رابط factory معمولاً فقط شامل یک متد برای ایجاد شیء است، که کوچک و خاص است و کلاینت‌ها را مجبور به implement متدهای غیرضروری نمی‌کند.  
این جداسازی رابط‌ها انعطاف‌پذیری را افزایش می‌دهد و وابستگی‌های غیرلازم را کاهش می‌دهد.

### اصل D (Dependency Inversion Principle)
الگوی Factory Method این اصل را تحقق می‌بخشد.  
کد کلاینت به abstraction (رابط factory) وابسته است نه به implementation خاص کلاس‌های concrete.  
این وارونگی وابستگی اجازه می‌دهد که تغییرات در implementation بدون تأثیر بر کلاینت انجام شود.

</div>

## سوال ۵
<div dir="rtl">

**کد تمیز**: کدی خوانا، ساده، قابل نگهداری و با ساختار منظم که اصول طراحی خوب را رعایت کرده و درک و اصلاح آن آسان است.  
**بدهی فنی**: مشکلات کیفیتی در کد (مثل میانبرها یا طراحی ضعیف) که در آینده هزینه و زمان بیشتری برای اصلاح نیاز دارند.  
**بوی بد**: نشانه‌هایی در کد (مانند پیچیدگی بیش‌ازحد یا تکرار) که حاکی از مشکلات طراحی یا پیاده‌سازی هستند و نیاز به بازسازی دارند.

</div>

## سوالات بخش ۲

<div dir="rtl">

1. **Bloaters**: این بوی بد به کدها، متدها یا کلاس‌هایی اشاره دارد که بیش از حد بزرگ و پیچیده شده‌اند و کار با آن‌ها دشوار است. این مشکلات معمولاً به مرور زمان و با عدم توجه به بازسازی کد ایجاد می‌شوند، مانند متدهای طولانی یا کلاس‌های بزرگ با تعداد زیادی فیلد و متد.

2. **Object-Oriented Abusers**: این دسته شامل کدهایی است که اصول برنامه‌نویسی شیءگرا به درستی در آن‌ها اعمال نشده یا ناقص پیاده‌سازی شده‌اند. مثال‌هایی مانند سوءاستفاده از وراثت یا استفاده نادرست از پلی‌مورفیسم در این دسته قرار می‌گیرند.

3. **Change Preventers**: این بوی بد به کدهایی اشاره دارد که تغییر در یک بخش از آن‌ها نیازمند تغییرات متعدد در بخش‌های دیگر است. این مشکل باعث پیچیدگی و هزینه بالای توسعه می‌شود، مانند کلاس‌هایی که بیش از حد به هم وابسته‌اند.

4. **Dispensables**: این دسته شامل کدها یا ساختارهایی است که غیرضروری بوده و حذف آن‌ها کد را تمیزتر، کارآمدتر و قابل فهم‌تر می‌کند. مثال‌هایی مانند کدهای غیرقابل دسترس (dead code) یا کامنت‌های اضافی در این دسته قرار دارند.

5. **Couplers**: این بوی بد به وابستگی بیش از حد بین کلاس‌ها یا واگذاری بیش از حد مسئولیت‌ها (delegation) اشاره دارد. این مشکل باعث کاهش انعطاف‌پذیری و افزایش پیچیدگی در نگهداری کد می‌شود، مانند استفاده بیش از حد از داده‌های کلاس دیگر.

</div>

## سوالات بخش ۳

<div dir="rtl">

### دسته‌بندی بوی بد Feature Envy
بوی بد **Feature Envy** در دسته **Couplers (جفت‌کننده‌ها)** قرار می‌گیرد. این بوی بد زمانی رخ می‌دهد که یک متد یا کلاس بیش از حد به داده‌ها یا متدهای یک کلاس دیگر وابسته است و به جای استفاده از قابلیت‌های کلاس خود، از ویژگی‌های کلاس دیگر استفاده می‌کند.

### بازآرایی پیشنهادی برای برطرف کردن Feature Envy
برای رفع این بوی بد، معمولاً از بازآرایی‌های زیر استفاده می‌شود:
- **Move Method**: اگر متدی بیش از حد از داده‌های کلاس دیگر استفاده می‌کند، آن متد را به کلاس مناسب منتقل کنید تا وابستگی کاهش یابد.
- **Extract Method**: اگر بخشی از متد به داده‌های کلاس دیگر وابسته است، آن بخش را به یک متد جدید در کلاس مقصد استخراج کنید.
- **Move Field**: در صورتی که یک فیلد به طور مداوم توسط کلاس دیگری استفاده می‌شود، آن فیلد را به کلاس مناسب منتقل کنید.

این بازآرایی‌ها باعث می‌شوند که کدها به کلاس‌هایی که به آن‌ها تعلق دارند نزدیک‌تر شوند و اصل **تعلق (Encapsulation)** بهتر رعایت شود.

### مواقعی که باید Feature Envy را نادیده گرفت
- **طراحی‌های عمدی با هدف خاص**: در برخی موارد، مانند الگوهای طراحی خاص (مثل Visitor یا Strategy)، وابستگی به ویژگی‌های کلاس دیگر بخشی از طراحی است و حذف آن منطقی نیست.
- **مواردی با پیچیدگی کم**: اگر وابستگی به کلاس دیگر ساده و محدود است و تغییر آن هزینه یا پیچیدگی بیشتری ایجاد می‌کند، می‌توان آن را نادیده گرفت.
- **بهینه‌سازی عملکرد**: در شرایطی که انتقال کدها به کلاس دیگر باعث کاهش قابل‌توجه عملکرد می‌شود (مثلاً در سیستم‌های با محدودیت منابع)، ممکن است بهتر باشد این بوی بد را تحمل کرد.
- **مراحل اولیه توسعه**: در فازهای اولیه که کد هنوز در حال تکامل است، تمرکز بر رفع این بوی بد ممکن است زودرس باشد و بهتر است به بازآرایی‌های بعدی موکول شود.

</div>

## سوالات بخش ۵

<div dir="rtl">

---

### 1. **Long Method (متد طولانی)**
- **فایل**: `GUIMethod.java`, `GUIClass.java`, `GUIList.java`, و غیره
- **توضیح**: بسیاری از متدها، مانند سازنده‌ها (`GUIMethod`, `GUIClass`, `GUIValueType`) یا متد `run`، حاوی کدهای طولانی و پیچیده هستند که چندین مسئولیت را در خود جای داده‌اند (مانند راه‌اندازی UI، مدیریت رویدادها، و به‌روزرسانی رابط کاربری). این امر خوانایی و نگهداری کد را کاهش می‌دهد.
- **پیشنهاد بهبود**:
    - باید متدهای طولانی را به متدهای کوچک‌تر و متمرکز تقسیم کرد. به عنوان مثال، در سازنده `GUIMethod`، می‌توان کد مربوط به تنظیم UI و افزودن DocumentListener را به متدهای جداگانه منتقل کرد.
    - باید از الگوی **Single Responsibility Principle (SRP)** استفاده کرد تا هر متد فقط یک کار مشخص انجام دهد.

---

### 2. **Duplicated Code (کد تکراری)**
- **فایل‌ها**: `GUIMethod.java`, `GUIConstructor.java`, `GUIAttribute.java`, `GUIValueType.java`, `GUIClass.java`
- **توضیح**: کدهای مربوط به تنظیم `JPanel`، افزودن `DocumentListener` برای `JTextField`، و اجرای حلقه‌های `run` در این کلاس‌ها بسیار مشابه هستند. به عنوان مثال، متد `run` در این کلاس‌ها ساختار مشابهی دارد که شامل به‌روزرسانی UI و استفاده از `Thread.sleep` است.
- **پیشنهاد بهبود**:
    - باید کدهای تکراری را به یک کلاس پایه یا یک متد ابزار (utility method) منتقل کرد. به عنوان مثال، می‌توان یک کلاس پایه انتزاعی برای `GUIListItem` ایجاد کرد که منطق مشترک `run` یا مدیریت UI را پیاده‌سازی کند.
    - باید از الگوهای طراحی مانند **Template Method** برای مدیریت رفتارهای مشترک استفاده کرد.

---

### 3. **Magic Numbers (اعداد جادویی)**
- **فایل‌ها**: `GUIMethod.java`, `GUIConstructor.java`, `GUIAttribute.java`, `GUIValueType.java`, `GUIList.java`, `GUIDiagram.java`
- **توضیح**: استفاده از عدد ثابت `399` یا `499` در متدهای `Thread.sleep` بدون توضیح یا مستندسازی دلیل این مقادیر. این اعداد خوانایی کد را کاهش می‌دهند و تغییر آن‌ها در آینده دشوار است.
- **پیشنهاد بهبود**:
    - باید این مقادیر را به ثابت‌های معنی‌دار (constants) تبدیل کرد. به عنوان مثال:
      ```java
      private static final int UI_UPDATE_INTERVAL_MS = 400;
      Thread.sleep(UI_UPDATE_INTERVAL_MS);
      ```
    - همچنین باید دلیل انتخاب این مقادیر را در مستندات یا نظرات توضیح داد.

---

### 4. **Thread Misuse (استفاده نادرست از نخ‌ها)**
- **فایل‌ها**: `GUIMethod.java`, `GUIConstructor.java`, `GUIAttribute.java`, `GUIValueType.java`, `GUIClass.java`, `GUIDiagram.java`, `GUIList.java`
- **توضیح**: این کلاس‌ها از `Thread` برای به‌روزرسانی مداوم UI استفاده می‌کنند، که شامل حلقه‌های بی‌پایان با `Thread.sleep` است. این روش غیربهینه است و می‌تواند باعث مشکلات عملکردی یا تداخل در Swing (که یک کتابخانه تک‌نخی است) شود. به‌روزرسانی UI باید در نخ EDT (Event Dispatch Thread) انجام شود.
- **پیشنهاد بهبود**:
    - باید به جای استفاده از `Thread` و `Thread.sleep`، از `javax.swing.Timer` برای به‌روزرسانی‌های دوره‌ای UI استفاده کرد. این تایمر به طور خودکار در EDT اجرا می‌شود.
    - مثال:
      ```java
      Timer timer = new Timer(400, e -> panel.updateUI());
      timer.start();
      ```
    - همچنین باید از مدل‌های رویدادمحور Swing برای مدیریت تغییرات UI استفاده کرد.

---

### 5. **Improper Error Handling (مدیریت نادرست خطاها)**
- **فایل‌ها**: `GUIMethod.java`, `GUIAttribute.java`, `GUIValueType.java`, `GUIClass.java`, `GUITextFieldSetter.java`
- **توضیح**: در این فایل‌ها، استثناها (مانند `NoSuchMethodException` یا `InterruptedException`) صرفاً چاپ می‌شوند (`e.printStackTrace()`) و هیچ اقدام اصلاحی انجام نمی‌شود. این روش می‌تواند باعث رفتار غیرقابل پیش‌بینی برنامه شود.
- **پیشنهاد بهبود**:
    - باید استثناها را به طور مناسب مدیریت کرد، مثلاً با نمایش پیام خطا به کاربر یا بازگرداندن برنامه به حالت پایدار.
    - باید از logging frameworkهایی مانند SLF4J یا Log4j به جای `printStackTrace` استفاده کرد.
    - مثال:
      ```java
      try {
          nameGetter.getDocument().addDocumentListener(...);
      } catch (NoSuchMethodException e) {
          logger.error("Failed to add DocumentListener for nameGetter", e);
          // اقدام اصلاحی، مانند نمایش پیام خطا
      }
      ```

---

### 6. **Feature Envy (حسادت به ویژگی‌ها)**
- **فایل**: `GUITextFieldSetter.java`
- **توضیح**: کلاس `GUITextFieldSetter` بیش از حد به متدهای `setName` یا `setTypeName` کلاس‌های دیگر وابسته است و از طریق reflection به آن‌ها دسترسی پیدا می‌کند. این نشان‌دهنده حسادت این کلاس به داده‌ها و رفتارهای کلاس‌های دیگر است.
- **پیشنهاد بهبود**:
    - باید منطق بررسی و تنظیم نام را به خود کلاس‌های `GUIAttribute`, `GUIMethod`, و غیره منتقل کرد.
    - باید از یک رابط (interface) یا الگوی طراحی مانند **Observer** برای مدیریت تغییرات در `JTextField` استفاده کرد، به جای استفاده از reflection که پیچیدگی و خطا را افزایش می‌دهد.

---

### 7. **Primitive Obsession (وسواس به داده‌های اولیه)**
- **فایل‌ها**: `GUIValueType.java`, `GUIAttribute.java`, `GUIMethod.java`
- **توضیح**: استفاده از رشته‌های خام (مانند `"method"`, `"constructor"`, `"name"`) به عنوان مقادیر اولیه یا عنوان‌ها در کلاس‌ها. این می‌تواند باعث خطاهای تایپی یا مشکلات نگهداری شود.
- **پیشنهاد بهبود**:
    - باید از ثابت‌ها (constants) یا نوع‌های شمارش‌شده (enum) برای این مقادیر استفاده کرد. به عنوان مثال:
      ```java
      public enum ComponentType {
          METHOD("method"),
          CONSTRUCTOR("constructor"),
          ATTRIBUTE("attribute");
          
          private final String displayName;
          ComponentType(String displayName) { this.displayName = displayName; }
          public String getDisplayName() { return displayName; }
      }
      ```
    - باید این مقادیر را در یک مکان مرکزی تعریف کرد تا تغییرات آسان‌تر شود.

---

### 8. **Large Class (کلاس بزرگ)**
- **فایل**: `GUIClass.java`
- **توضیح**: کلاس `GUIClass` مسئولیت‌های زیادی را بر عهده دارد، از جمله مدیریت UI، لیست‌های ویژگی‌ها، متدها، سازنده‌ها، و حتی ذخیره‌سازی XML. این کلاس بیش از حد بزرگ و پیچیده است.
- **پیشنهاد بهبود**:
    - باید مسئولیت‌های مختلف را به کلاس‌های جداگانه تقسیم کرد. به عنوان مثال، منطق XML را به یک کلاس جداگانه مانند `XMLSerializer` منتقل کرد.
    - باید از الگوی **Facade** یا **Mediator** برای هماهنگی بین اجزای مختلف استفاده کرد.

---

### 9. **Inappropriate Intimacy (صمیمیت نامناسب)**
- **فایل‌ها**: `GUIClass.java`, `GUITextFieldSetter.java`
- **توضیح**: کلاس `GUITextFieldSetter` از طریق reflection به متدهای داخلی کلاس‌های دیگر (مانند `setName` یا `setSuperClass`) دسترسی دارد، که نقض اصل کپسوله‌سازی است. همچنین، `GUIClass` به صورت مستقیم به `Main.document` و `Main.transformer` دسترسی دارد.
- **پیشنهاد بهبود**:
    - باید از متدهای عمومی (public) یا رابط‌ها برای تعامل با کلاس‌ها استفاده کرد و از reflection اجتناب کرد.
    - باید وابستگی به `Main` را حذف کرد و از تزریق وابستگی (Dependency Injection) برای ارائه اشیاء مورد نیاز استفاده کرد.

---

### 10. **Dead Code (کد مرده)**
- **فایل**: `DiagramGetter.java`
- **توضیح**: خط `Graphics graphics = new DebugGraphics();` در متد `init` استفاده نمی‌شود و به نظر می‌رسد کد مرده باشد. همچنین، برخی متدهای دیگر (مانند `setLayout` در `GUIList.java`) ممکن است به ندرت یا هرگز استفاده نشوند.
- **پیشنهاد بهبود**:
    - باید کدهای استفاده‌نشده را حذف کرد تا خوانایی و نگهداری کد بهبود یابد.
    - باید از ابزارهای تحلیل کد مانند SonarQube برای شناسایی و حذف کدهای مرده استفاده کرد.

---
</div>