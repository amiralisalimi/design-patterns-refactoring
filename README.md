# DesignPatternsRefactoring
SE Lab - Assignment 6 - SUT | 14033 

# بخش اول
<div dir="rtl">

# سیستم مدیریت پویای مصرف انرژی هوشمند (README)

این پروژه یک شبیه‌سازی ساده از مدیریت انرژی در یک ساختمان اداری است. سیستم باید بتواند با توجه به شرایط، حالت کار تجهیزات را تغییر دهد و هم‌زمان هزینه‌ی انرژی را با سیاست‌های مختلف محاسبه کند. پیاده‌سازی بر پایه‌ی دو الگوی رفتاری State و Strategy انجام شده و روند توسعه با رویکرد TDD پیش رفته است.

---

## الگوهای طراحی به‌کاررفته و چرایی آن‌ها

## پرسش ۲

هر دو الگوی State و Strategy در دسته‌ی الگوهای رفتاری یا Behavioral قرار می‌گیرند.

## پرسش ۳

برای مدیریت حالت‌های سیستم از الگوی State استفاده شده است. دلیل اصلی این انتخاب آن است که وضعیت سیستم همیشه یکی از سه حالت مشخص است: فعال، اقتصادی یا خاموش. هر حالت رفتار مخصوص به خودش دارد و اگر بخواهیم همه این رفتارها را با شرط‌های پشت سر هم در یک کلاس قرار دهیم، کد پیچیده می‌شود. State کمک می‌کند هر حالت به شکل یک کلاس مستقل تعریف شود و تغییر حالت فقط با جایگزین کردن شیء جدید انجام شود. به این ترتیب هم خوانایی کد بالا می‌رود و هم افزودن حالت‌های تازه بدون دست‌کاری منطق فعلی ممکن خواهد بود.

برای محاسبه هزینه انرژی از الگوی Strategy استفاده شده است. Strategy برای زمانی استفاده می‌شود که یک <B>الگوریتم یا سیاست</B> قابل تعویض است و مستقل از وضعیت سیستم است. چون سیاست‌های محاسبه هزینه ممکن است در زمان اجرا تغییر کنند، بهتر است منطق هر تعرفه در یک استراتژی جداگانه نگهداری شود. به این شکل کلاس محاسبه هزینه صرفاً به یک اینترفیس عمومی متکی است و نیازی ندارد بداند تعرفه فعلی معمولی است یا اوج مصرف یا سبز. تغییر تعرفه هم فقط با تغییر استراتژی انجام می‌شود. این باعث می‌شود کد باز و قابل توسعه بماند و بتوان سیاست‌های جدیدی را به‌سادگی اضافه کرد.

به طور خلاصه، State برای زمانی استفاده شد که رفتار سیستم به وضعیت جاری آن وابسته بود و Strategy برای زمانی به‌کار رفت که روش محاسبه هزینه قابل تعویض بود.

## تحقق الگوها در پیاده‌سازی

پیاده‌سازی State به این شکل است که یک اینترفیس EnergyState تعریف شده است و هر حالت سیستم (ActiveState، EcoState، ShutdownState) یک کلاس مجزا پیاده‌سازی می‌کند. BuildingContext حالت جاری را نگه می‌دارد و با فراخوانی متد setState می‌توان وضعیت را تغییر داد. این طراحی تضمین می‌کند که هر تغییر وضعیت، رفتار سیستم را به صورت خودکار به‌روز می‌کند و کد اصلی وابستگی مستقیم به حالت ندارد.

پیاده‌سازی Strategy شامل تعریف یک اینترفیس CostStrategy است که متد calculateCost را ارائه می‌دهد. هر تعرفه انرژی یک کلاس پیاده‌ساز است (StandardCostStrategy، PeakCostStrategy، GreenCostStrategy) و CostCalculator استراتژی جاری را نگه می‌دارد. تغییر تعرفه با فراخوانی setStrategy انجام می‌شود و هیچ تغییری در کد بخش‌های دیگر نیاز نیست. این طراحی تحقق کامل استقلال و تعویض‌پذیری الگوریتم محاسبه هزینه را نشان می‌دهد.

---

## معماری و پیاده‌سازی

ساختار کد به دو بسته اصلی تقسیم شده است: state و strategy. کلاس MainApp منوی متنی و جریان اجرای برنامه را مدیریت می‌کند و نقش‌های Manager و User را از هم جدا می‌کند.

### بخش State (وضعیت سیستم انرژی)

EnergyState یک اینترفیس با دو متد است: getEnergyConsumption و getStatus. سه کلاس پیاده‌ساز عبارتند از ActiveState با مصرف صد واحد و پیام «System is fully active»، EcoState با مصرف چهل واحد و پیام «System is in eco mode»، و ShutdownState با مصرف صفر واحد و پیام «System is shut down». کلاس BuildingContext فقط به اینترفیس State تکیه دارد، حالت جاری را نگه می‌دارد و از طریق setState تعویض می‌کند. برای نمایش وضعیت showStatus و برای دسترسی به مصرف جاری getCurrentConsumption ارائه می‌دهد.

### بخش Strategy (سیاست محاسبه هزینه)

CostStrategy اینترفیس محاسبه هزینه است که متد calculateCost را تعریف می‌کند. پیاده‌سازی‌ها شامل StandardCostStrategy با نرخ پانصد، PeakCostStrategy با نرخ هزار و GreenCostStrategy با نرخ سیصد هستند. کلاس CostCalculator نقش Context را دارد و استراتژی جاری را نگه می‌دارد. تغییر تعرفه فقط با setStrategy انجام می‌شود.

### رابط کاربری و نقش‌ها

برنامه اصلی با منو اجرا می‌شود. ابتدا نقش انتخاب می‌شود. اگر Manager انتخاب شود امکان تغییر حالت سیستم یا تغییر سیاست هزینه وجود دارد. اگر User انتخاب شود می‌توان وضعیت فعلی را دید، هزینه کل را بر اساس مصرف حالت جاری محاسبه کرد یا تعداد واحد دلخواهی را برای شبیه‌سازی وارد کرد. برنامه از ابتدا با حالت Active و سیاست Standard بالا می‌آید.

---

## آزمون‌های TDD

توسعه با نوشتن تست‌ها آغاز شد. ابتدا تست‌های شکست‌خورده برای هر دو بخش نوشته شد و سپس حداقل کد لازم برای سبز شدن آن‌ها پیاده شد. در بخش Strategy، آزمون‌ها صحت اعداد هر تعرفه و قابلیت تعویض استراتژی در زمان اجرا را بررسی می‌کنند. در بخش State، آزمون‌ها اطمینان می‌دهند که هر حالت مقدار مصرف و پیام متناظر خود را دارد. این روند باعث شد با رشد کد، اعتماد به رفتار سیستم حفظ شود و هر تغییر به سرعت با آزمون پوشش داده شود.
</div>



# بخش دوم

# ریفکتورها و بازآرایی‌های پروژه MiniJava

## Facade – CompilerFacade و Compiler
یک Facade برای Compiler ساخته شد تا دسترسی به Parser و Scanner ساده شود. کاربران دیگر نیازی به ایجاد یا مدیریت مستقیم این کلاس‌ها ندارند و فقط با CompilerFacade کار می‌کنند.

## Strategy – ActionStrategy
برای جایگزینی switch-case در parser، هر نوع Action (Shift, Reduce, Accept) یک کلاس جداگانه با متد execute دارد. این باعث شد اضافه کردن action جدید بدون تغییر در parser ممکن شود و کد خواناتر و قابل تست‌تر شود.

## Separate Query from Modifier
توابعی که داده را query می‌کنند نباید هیچ side-effect یا تغییر وضعیت ایجاد کنند. عملیات تغییر وضعیت و ErrorHandler در توابع جداگانه انجام شد تا عملیات خواندن داده بدون اثر جانبی باشد.

## Self Encapsulated Field
فیلدهای کلاس‌ها private شدند و تمام دسترسی‌ها از طریق getter و setter انجام می‌شود. این کار باعث کنترل بهتر روی فیلدها و امکان اضافه کردن validation می‌شود.

## Null Object – Klass.getField
به جای بازگرداندن null هنگام پیدا نشدن فیلد، یک NullSymbol امن برگردانده می‌شود. این روش جلوی NullPointerException را می‌گیرد و کد کلاینت بدون نیاز به بررسی null، پیش‌بینی‌پذیر است.

## Extract Method – ParseTable
کد parsing جدول parser در constructor به متدهای جداگانه مثل parseRow و parsecol منتقل شد. constructor کوتاه‌تر و خواناتر شد. Magic String ها نیز به صورت ثابت تعریف شدند تا کد خواناتر شود.


# پاسخ بقیه سوالات

## سوال ۱
### 1- Creational
<p>تمرکر این دسته روی نحوه ایجاد و نمونه سازی از اشیا است به شکلی که سیستم کمتر به جزئیات ایجاد وابسته باشد. این الگو ها انعطاف پذیری  در ایجاد اشیا و کپسوله سازی روند ساخت را فراهم می‌کنند.</p>

#### نمونه ها
- Singleton
- Factory Method

### 2- Structural
<p>این دسته روی ترکیب کلاس ها و اشیا تمرکز دارد تا ساختار های بزرگ تر و انعطاف پذیر تر ساخته شوند. هدف اصلی آن ساده سازی روابط و ترکیب ها برای افزایش قابلیت استفاده مجدد است.</p>

#### نمونه ها
- Adapter
- Composite

### 3- Behavioral
<p>این دسته به نحوه تعامل و مسئولیت بین اشیا می پردازد.  هدف آن تعریف الگوهایی برای ارتباط، همکاری و تخصیص وظایف میان اشیا است.</p>

#### نمونه ها
- Observer
- Strategy

## سوال ۴

<div dir='rtl'>

### اصل S (Single Responsibility Principle)
الگوی Factory Method این اصل را تحقق می‌بخشد.  
در این الگو، مسئولیت ایجاد اشیاء به کلاس factory سپرده می‌شود و کلاس‌های دیگر فقط از اشیاء استفاده می‌کنند بدون دخالت در فرآیند ساخت.  
این جداسازی مسئولیت‌ها باعث می‌شود هر کلاس تنها یک وظیفه داشته باشد و کد تمیزتر شود.

### اصل O (Open-Closed Principle)
الگوی Factory Method این اصل را تحقق می‌بخشد.  
کلاس factory برای گسترش باز است، زیرا می‌توان زیرکلاس‌های جدیدی اضافه کرد تا انواع جدیدی از اشیاء ایجاد شود بدون تغییر کد موجود.  
در عین حال، برای تغییرات بسته است، زیرا کد کلاینت وابسته به abstraction است و نیاز به اصلاح ندارد.

### اصل L (Liskov Substitution Principle)
الگوی Factory Method این اصل را تحقق می‌بخشد.  
زیرکلاس‌های factory می‌توانند جایگزین superclass شوند، زیرا متد factory را override می‌کنند بدون اینکه رفتار کلی سیستم را مختل کنند.  
این اصل تضمین می‌کند که اشیاء ساخته‌شده توسط زیرکلاس‌ها با انتظارات superclass سازگار باشند.

### اصل I (Interface Segregation Principle)
الگوی Factory Method این اصل را تحقق می‌بخشد.  
رابط factory معمولاً فقط شامل یک متد برای ایجاد شیء است، که کوچک و خاص است و کلاینت‌ها را مجبور به implement متدهای غیرضروری نمی‌کند.  
این جداسازی رابط‌ها انعطاف‌پذیری را افزایش می‌دهد و وابستگی‌های غیرلازم را کاهش می‌دهد.

### اصل D (Dependency Inversion Principle)
الگوی Factory Method این اصل را تحقق می‌بخشد.  
کد کلاینت به abstraction (رابط factory) وابسته است نه به implementation خاص کلاس‌های concrete.  
این وارونگی وابستگی اجازه می‌دهد که تغییرات در implementation بدون تأثیر بر کلاینت انجام شود.

</div>

## سوال ۵
<div dir="rtl">

**کد تمیز**: کدی خوانا، ساده، قابل نگهداری و با ساختار منظم که اصول طراحی خوب را رعایت کرده و درک و اصلاح آن آسان است.  
**بدهی فنی**: مشکلات کیفیتی در کد (مثل میانبرها یا طراحی ضعیف) که در آینده هزینه و زمان بیشتری برای اصلاح نیاز دارند.  
**بوی بد**: نشانه‌هایی در کد (مانند پیچیدگی بیش‌ازحد یا تکرار) که حاکی از مشکلات طراحی یا پیاده‌سازی هستند و نیاز به بازسازی دارند.

</div>

## سوالات بخش ۲

<div dir="rtl">

1. **Bloaters**: این بوی بد به کدها، متدها یا کلاس‌هایی اشاره دارد که بیش از حد بزرگ و پیچیده شده‌اند و کار با آن‌ها دشوار است. این مشکلات معمولاً به مرور زمان و با عدم توجه به بازسازی کد ایجاد می‌شوند، مانند متدهای طولانی یا کلاس‌های بزرگ با تعداد زیادی فیلد و متد.

2. **Object-Oriented Abusers**: این دسته شامل کدهایی است که اصول برنامه‌نویسی شیءگرا به درستی در آن‌ها اعمال نشده یا ناقص پیاده‌سازی شده‌اند. مثال‌هایی مانند سوءاستفاده از وراثت یا استفاده نادرست از پلی‌مورفیسم در این دسته قرار می‌گیرند.

3. **Change Preventers**: این بوی بد به کدهایی اشاره دارد که تغییر در یک بخش از آن‌ها نیازمند تغییرات متعدد در بخش‌های دیگر است. این مشکل باعث پیچیدگی و هزینه بالای توسعه می‌شود، مانند کلاس‌هایی که بیش از حد به هم وابسته‌اند.

4. **Dispensables**: این دسته شامل کدها یا ساختارهایی است که غیرضروری بوده و حذف آن‌ها کد را تمیزتر، کارآمدتر و قابل فهم‌تر می‌کند. مثال‌هایی مانند کدهای غیرقابل دسترس (dead code) یا کامنت‌های اضافی در این دسته قرار دارند.

5. **Couplers**: این بوی بد به وابستگی بیش از حد بین کلاس‌ها یا واگذاری بیش از حد مسئولیت‌ها (delegation) اشاره دارد. این مشکل باعث کاهش انعطاف‌پذیری و افزایش پیچیدگی در نگهداری کد می‌شود، مانند استفاده بیش از حد از داده‌های کلاس دیگر.

</div>

## سوالات بخش ۳

<div dir="rtl">

### دسته‌بندی بوی بد Feature Envy
بوی بد **Feature Envy** در دسته **Couplers (جفت‌کننده‌ها)** قرار می‌گیرد. این بوی بد زمانی رخ می‌دهد که یک متد یا کلاس بیش از حد به داده‌ها یا متدهای یک کلاس دیگر وابسته است و به جای استفاده از قابلیت‌های کلاس خود، از ویژگی‌های کلاس دیگر استفاده می‌کند.

### بازآرایی پیشنهادی برای برطرف کردن Feature Envy
برای رفع این بوی بد، معمولاً از بازآرایی‌های زیر استفاده می‌شود:
- **Move Method**: اگر متدی بیش از حد از داده‌های کلاس دیگر استفاده می‌کند، آن متد را به کلاس مناسب منتقل کنید تا وابستگی کاهش یابد.
- **Extract Method**: اگر بخشی از متد به داده‌های کلاس دیگر وابسته است، آن بخش را به یک متد جدید در کلاس مقصد استخراج کنید.
- **Move Field**: در صورتی که یک فیلد به طور مداوم توسط کلاس دیگری استفاده می‌شود، آن فیلد را به کلاس مناسب منتقل کنید.

این بازآرایی‌ها باعث می‌شوند که کدها به کلاس‌هایی که به آن‌ها تعلق دارند نزدیک‌تر شوند و اصل **تعلق (Encapsulation)** بهتر رعایت شود.

### مواقعی که باید Feature Envy را نادیده گرفت
- **طراحی‌های عمدی با هدف خاص**: در برخی موارد، مانند الگوهای طراحی خاص (مثل Visitor یا Strategy)، وابستگی به ویژگی‌های کلاس دیگر بخشی از طراحی است و حذف آن منطقی نیست.
- **مواردی با پیچیدگی کم**: اگر وابستگی به کلاس دیگر ساده و محدود است و تغییر آن هزینه یا پیچیدگی بیشتری ایجاد می‌کند، می‌توان آن را نادیده گرفت.
- **بهینه‌سازی عملکرد**: در شرایطی که انتقال کدها به کلاس دیگر باعث کاهش قابل‌توجه عملکرد می‌شود (مثلاً در سیستم‌های با محدودیت منابع)، ممکن است بهتر باشد این بوی بد را تحمل کرد.
- **مراحل اولیه توسعه**: در فازهای اولیه که کد هنوز در حال تکامل است، تمرکز بر رفع این بوی بد ممکن است زودرس باشد و بهتر است به بازآرایی‌های بعدی موکول شود.

</div>