<div dir="rtl">
# سیستم مدیریت پویای مصرف انرژی هوشمند (README)

این پروژه یک شبیه‌سازی ساده از مدیریت انرژی در یک ساختمان اداری است. سیستم باید بتواند با توجه به شرایط، حالت کار تجهیزات را تغییر دهد و هم‌زمان هزینه‌ی انرژی را با سیاست‌های مختلف محاسبه کند. پیاده‌سازی بر پایه‌ی دو الگوی رفتاری State و Strategy انجام شده و روند توسعه با رویکرد TDD پیش رفته است.

---

## الگوهای طراحی به‌کاررفته و چرایی آن‌ها

## پرسش ۲

هر دو الگوی State و Strategy در دسته‌ی الگوهای رفتاری یا Behavioral قرار می‌گیرند.

## پرسش ۳

برای مدیریت حالت‌های سیستم از الگوی State استفاده شده است. دلیل اصلی این انتخاب آن است که وضعیت سیستم همیشه یکی از سه حالت مشخص است: فعال، اقتصادی یا خاموش. هر حالت رفتار مخصوص به خودش دارد و اگر بخواهیم همه این رفتارها را با شرط‌های پشت سر هم در یک کلاس قرار دهیم، کد پیچیده می‌شود. State کمک می‌کند هر حالت به شکل یک کلاس مستقل تعریف شود و تغییر حالت فقط با جایگزین کردن شیء جدید انجام شود. به این ترتیب هم خوانایی کد بالا می‌رود و هم افزودن حالت‌های تازه بدون دست‌کاری منطق فعلی ممکن خواهد بود.

برای محاسبه هزینه انرژی از الگوی Strategy استفاده شده است. Strategy برای زمانی استفاده می‌شود که یک <B>الگوریتم یا سیاست</B> قابل تعویض است و مستقل از وضعیت سیستم است. چون سیاست‌های محاسبه هزینه ممکن است در زمان اجرا تغییر کنند، بهتر است منطق هر تعرفه در یک استراتژی جداگانه نگهداری شود. به این شکل کلاس محاسبه هزینه صرفاً به یک اینترفیس عمومی متکی است و نیازی ندارد بداند تعرفه فعلی معمولی است یا اوج مصرف یا سبز. تغییر تعرفه هم فقط با تغییر استراتژی انجام می‌شود. این باعث می‌شود کد باز و قابل توسعه بماند و بتوان سیاست‌های جدیدی را به‌سادگی اضافه کرد.

به طور خلاصه، State برای زمانی استفاده شد که رفتار سیستم به وضعیت جاری آن وابسته بود و Strategy برای زمانی به‌کار رفت که روش محاسبه هزینه قابل تعویض بود.

---

## معماری و پیاده‌سازی

ساختار کد به دو بسته اصلی تقسیم شده است: state و strategy. کلاس MainApp منوی متنی و جریان اجرای برنامه را مدیریت می‌کند و نقش‌های Manager و User را از هم جدا می‌کند.

### بخش State (وضعیت سیستم انرژی)

EnergyState یک اینترفیس با دو متد است: getEnergyConsumption و getStatus. سه کلاس پیاده‌ساز عبارتند از ActiveState با مصرف صد واحد و پیام «System is fully active»، EcoState با مصرف چهل واحد و پیام «System is in eco mode»، و ShutdownState با مصرف صفر واحد و پیام «System is shut down». کلاس BuildingContext فقط به اینترفیس State تکیه دارد، حالت جاری را نگه می‌دارد و از طریق setState تعویض می‌کند. برای نمایش وضعیت showStatus و برای دسترسی به مصرف جاری getCurrentConsumption ارائه می‌دهد.

### بخش Strategy (سیاست محاسبه هزینه)

CostStrategy اینترفیس محاسبه هزینه است که متد calculateCost را تعریف می‌کند. پیاده‌سازی‌ها شامل StandardCostStrategy با نرخ پانصد، PeakCostStrategy با نرخ هزار و GreenCostStrategy با نرخ سیصد هستند. کلاس CostCalculator نقش Context را دارد و استراتژی جاری را نگه می‌دارد. تغییر تعرفه فقط با setStrategy انجام می‌شود.

### رابط کاربری و نقش‌ها

برنامه اصلی با منو اجرا می‌شود. ابتدا نقش انتخاب می‌شود. اگر Manager انتخاب شود امکان تغییر حالت سیستم یا تغییر سیاست هزینه وجود دارد. اگر User انتخاب شود می‌توان وضعیت فعلی را دید، هزینه کل را بر اساس مصرف حالت جاری محاسبه کرد یا تعداد واحد دلخواهی را برای شبیه‌سازی وارد کرد. برنامه از ابتدا با حالت Active و سیاست Standard بالا می‌آید.

---

## آزمون‌های TDD

توسعه با نوشتن تست‌ها آغاز شد. ابتدا تست‌های شکست‌خورده برای هر دو بخش نوشته شد و سپس حداقل کد لازم برای سبز شدن آن‌ها پیاده شد. در بخش Strategy، آزمون‌ها صحت اعداد هر تعرفه و قابلیت تعویض استراتژی در زمان اجرا را بررسی می‌کنند. در بخش State، آزمون‌ها اطمینان می‌دهند که هر حالت مقدار مصرف و پیام متناظر خود را دارد. این روند باعث شد با رشد کد، اعتماد به رفتار سیستم حفظ شود و هر تغییر به سرعت با آزمون پوشش داده شود.
</div>